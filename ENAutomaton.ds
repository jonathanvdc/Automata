using std;

namespace Automata
{
    /// <summary>
    /// Defines a non-deterministic finite automaton with epsilon transitions.
    /// </summary>
    public struct ENFAutomaton<TState, TChar> : IAutomaton<TChar>
    {
        public const this(set TState StartState, set LinearSet<TState> AcceptingStates, set TransitionTable<Pair<TState, Optional<TChar>>, LinearSet<TState>> TransitionFunction);
        
        public TState StartState { const get; private set; }
        public LinearSet<TState> AcceptingStates { const get; private set; }
        public TransitionTable<Pair<TState, Optional<TChar>>, LinearSet<TState>> TransitionFunction { const get; private set; }
        
        public const LinearSet<TState> PerformTransition(TState State, Optional<TChar> Character)
        {
            var transFun = TransitionFunction;
            return transFun.Apply(new Pair<TState, Optional<TChar>>(State, Character));
        }
        public const LinearSet<TState> PerformAllTransitions(LinearSet<TState> States, Optional<TChar> Character)
        {
            var results = new LinearSet<TState>();
            foreach (var val in States.Items)
            {
                results.AddAll(PerformTransition(val, Character));
            }
            return results;
        }
        public const LinearSet<TState> Eclose(TState State)
        {
            LinearSet<TState> results = new LinearSet<TState>();
            LinearSet<TState> step = new LinearSet<TState>();
            step.Add(State);
            while (!step.IsEmpty)
            {
                var last = step.Last;
                results.Add(last);
                step.RemoveLast();
                var nextStep = new LinearSet<TState>();
                
                var trans = PerformTransition(last, new Optional<TChar>());
                foreach (var item in trans.Items)
                    if (!results.Contains(item))
                {
                    step.Add(item);
                }
            }
            return results;
        }
        public const LinearSet<TState> Eclose(LinearSet<TState> States)
        {
            LinearSet<TState> vals = new LinearSet<TState>();
            foreach (var item in States.Items)
            {
                vals.AddAll(Eclose(item));
            }
            return vals;
        }
        
        public const LinearSet<TState> PerformExtendedTransition(TState State, TChar[] Characters)
        {
            var states = Eclose(State);
            foreach (var item in Characters)
            {
                var optItem = new Optional<TChar>(item);
                states = Eclose(PerformAllTransitions(states, optItem));
            }
            return states;
        }
        
        public const bool ContainsAcceptingState(LinearSet<TState> States)
        {
            var acceptStates = AcceptingStates;
            var intersection = acceptStates.Intersect(States);
            return !intersection.IsEmpty;
        }
        
        public const bool Accepts(TChar[] Characters)
        {
            return ContainsAcceptingState(PerfromExtendedTransition(StartState, Characters));
        }
    }
}